//! https://adventofcode.com/2023/day/18

pub mod parser;

#[derive(Debug, Clone, Copy)]
enum Direction {
    N,
    S,
    E,
    W,
}

#[derive(Debug, Clone, Copy)]
struct Coord {
    x: i64,
    y: i64,
}

impl Coord {
    fn shift(&self, direction: Direction, distance: i64) -> Coord {
        match direction {
            Direction::N => Coord {
                x: self.x,
                y: self.y - distance,
            },
            Direction::S => Coord {
                x: self.x,
                y: self.y + distance,
            },
            Direction::E => Coord {
                x: self.x + distance,
                y: self.y,
            },
            Direction::W => Coord {
                x: self.x - distance,
                y: self.y,
            },
        }
    }
}

impl From<(i64, i64)> for Coord {
    fn from((x, y): (i64, i64)) -> Coord {
        Coord { x, y }
    }
}

#[derive(Debug)]
struct Edge {
    start: Coord,
    end: Coord,
}

#[derive(Debug, Clone)]
pub struct EdgeDesc {
    direction: Direction,
    length: i64,
}

fn generate_edges(edge_descs: &Vec<EdgeDesc>) -> Vec<Edge> {
    let mut edges = Vec::new();
    let mut start_coord = Coord::from((0, 0));

    for desc in edge_descs {
        let end_coord = start_coord.shift(desc.direction, desc.length);
        edges.push(Edge {
            start: start_coord,
            end: end_coord,
        });

        start_coord = end_coord;
    }

    edges
}

/// Compute the area of a polygon given as a list of edges using the Shoelace formula:
/// ((x1*y2 - y1*x2) + (x2*y3 - x3*y2) + ... + (xn*y1 - yn*x1)) / 2
///
/// The Shoelace formula gives the area of the polygon as if its edges are passing through the
/// center of the outline of the grid. However, we need to include the whole of the outline. The
/// formula accounts for 1/4 for each outside corner tile, 3/4 for each inside corner tile, and 1/2
/// for each tile on the edge which is not a corner. We have the mandatory 4 outside corners, and
/// for each inside corner we have another outside corner, so they cancel each out as if they were
/// two edge tiles. You can understand this better with an example:
///
/// #######
/// #     #
/// ###   #
///   #   #
/// ###   #
/// #     #
/// #######
///
/// To account for the remainder of the outline of perimeter P we need to add: 4 * 3/4 + (P-4) * 1/2
/// to the area generated by the Shoelace formula.
///
fn compute_polygon_area(edges: &Vec<Edge>, perimeter: i64) -> i64 {
    let mut area: i64 = 0;

    for edge in edges {
        area += edge.start.x * edge.end.y - edge.start.y * edge.end.x;
    }

    let correction = 3 + (perimeter - 4) / 2;
    let area = area.abs() / 2 + correction;
    area
}

/// Compute the area of the polygon defined by the dug edges.
pub fn solve(edge_descs: &Vec<EdgeDesc>) -> i64 {
    let edges = generate_edges(edge_descs);
    let perimeter = edge_descs.iter().map(|desc| desc.length).sum();
    compute_polygon_area(&edges, perimeter) as i64
}

/// Solve using the first set of instructions (direction and length).
pub fn solve_part1(edge_descs: &Vec<(EdgeDesc, EdgeDesc)>) -> i64 {
    let descs = edge_descs.iter().cloned().map(|(desc, _)| desc).collect();
    solve(&descs)
}

/// Solve using the second set of instructions (direction and length), decoded from color codes.
pub fn solve_part2(edge_descs: &Vec<(EdgeDesc, EdgeDesc)>) -> i64 {
    let descs = edge_descs.iter().cloned().map(|(_, desc)| desc).collect();
    solve(&descs)
}

#[cfg(test)]
mod tests {
    use super::*;
    use indoc::indoc;

    #[test]
    fn test1() {
        let input = indoc! {"
            R 6 (#70c710)
            D 5 (#0dc571)
            L 2 (#5713f0)
            D 2 (#d2c081)
            R 2 (#59c680)
            D 2 (#411b91)
            L 5 (#8ceee2)
            U 2 (#caa173)
            L 1 (#1b58a2)
            U 2 (#caa171)
            R 2 (#7807d2)
            U 3 (#a77fa3)
            L 2 (#015232)
            U 2 (#7a21e3)
        "};

        let edges = parser::parse_input(&input).unwrap();
        let result = solve_part1(&edges);
        assert_eq!(result, 62);
        let result = solve_part2(&edges);
        assert_eq!(result, 952408144115);
    }
}
