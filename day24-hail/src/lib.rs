//! https://adventofcode.com/2023/day/24

use itertools::Itertools;
use num_bigint::BigInt;
use num_traits::{cast::ToPrimitive, Zero};

pub mod parser;

#[derive(Debug, Clone, Copy, PartialEq)]
struct Coord3 {
    x: i64,
    y: i64,
    z: i64,
}

impl Coord3 {
    pub fn add(&self, other: &Coord3) -> Coord3 {
        Coord3 {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
        }
    }

    pub fn project_to_xy(&self) -> Coord2 {
        Coord2 {
            x: self.x,
            y: self.y,
        }
    }

    pub fn project_to_xz(&self) -> Coord2 {
        Coord2 {
            x: self.x,
            y: self.z,
        }
    }
}

impl From<(i64, i64, i64)> for Coord3 {
    fn from((x, y, z): (i64, i64, i64)) -> Coord3 {
        Coord3 { x, y, z }
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
struct Coord2 {
    x: i64,
    y: i64,
}

impl Coord2 {
    pub fn as_tuple_f64(self) -> (f64, f64) {
        (self.x as f64, self.y as f64)
    }
}

impl From<(i64, i64)> for Coord2 {
    fn from((x, y): (i64, i64)) -> Coord2 {
        Coord2 { x, y }
    }
}

#[derive(Debug, PartialEq)]
struct Hailstone {
    position: Coord3,
    velocity: Coord3,
}

#[derive(Debug)]
pub struct InputConfiguration {
    hailstones: Vec<Hailstone>,
}

/// Calculate the intersection point of two lines, when given two points on each line, by using
/// determinants as explained here:
/// https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
///
/// Parameters `p1` and `p2` are points belonging to the first line, while `p3` and `p4` belong to
/// the second line.
///
/// We must use BigInt for the calculation due to coordinates being i64. If we use i64 instead, the
/// multiplication overflows. If we use f64, the rounding error is too large.
#[allow(dead_code)]
fn cacl_intersection_point_1(p1: &Coord2, p2: &Coord2, p3: &Coord2, p4: &Coord2) -> Option<Coord2> {
    let x1 = &BigInt::from(p1.x);
    let y1 = &BigInt::from(p1.y);
    let x2 = &BigInt::from(p2.x);
    let y2 = &BigInt::from(p2.y);
    let x3 = &BigInt::from(p3.x);
    let y3 = &BigInt::from(p3.y);
    let x4 = &BigInt::from(p4.x);
    let y4 = &BigInt::from(p4.y);

    // If the denominator is zero, then the lines are parallel
    let denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if denom == Zero::zero() {
        return None;
    }

    // Coordinates of the intersection point
    let px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / &denom;
    let py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / &denom;

    let px = px.to_i64().unwrap();
    let py = py.to_i64().unwrap();

    Some(Coord2::from((px, py)))
}

/// Calculate the intersection point of two lines, when given two points on each line, by computing
/// line slopes and y-intercepts as explained in the following StackOverflow answer:
/// https://stackoverflow.com/a/27474217
///
/// Parameters `p1` and `p2` are points belonging to the first line, while `p3` and `p4` belong to
/// the second line.
#[allow(dead_code)]
fn cacl_intersection_point_2(p1: &Coord2, p2: &Coord2, p3: &Coord2, p4: &Coord2) -> Option<Coord2> {
    let (x1, y1) = p1.as_tuple_f64();
    let (x2, y2) = p2.as_tuple_f64();
    let (x3, y3) = p3.as_tuple_f64();
    let (x4, y4) = p4.as_tuple_f64();

    let slope1 = (y2 - y1) / (x2 - x1);
    let slope2 = (y4 - y3) / (x4 - x3);

    let y_intercept_1 = y1 - slope1 * x1;
    let y_intercept_2 = y3 - slope2 * x3;

    let px = (y_intercept_2 - y_intercept_1) / (slope1 - slope2);
    let py = slope1 * px + y_intercept_1;

    Some(Coord2::from((px as i64, py as i64)))
}

/// Return true if lines generated by the trajectories of hailstones `h1` and `h2` intersect within
/// the area bounded by min and max coordinate values.
fn paths_intersect_2d(h1: &Hailstone, h2: &Hailstone, min_coord: i64, max_coord: i64) -> bool {
    // Two points on the line created by the trajectory of the first hailstone
    let p1 = h1.position.project_to_xy();
    let p2 = h1.position.add(&h1.velocity).project_to_xy();

    // Two points on the line created by the trajectory of the second hailstone
    let p3 = h2.position.project_to_xy();
    let p4 = h2.position.add(&h2.velocity).project_to_xy();

    let pi = match cacl_intersection_point_1(&p1, &p2, &p3, &p4) {
        Some(pi) => pi,
        None => return false,
    };

    let inside_area =
        pi.x >= min_coord && pi.x <= max_coord && pi.y >= min_coord && pi.y <= max_coord;

    // Collision point is in the past if any hailstone is moving away from it
    let in_the_past = false
        || (h1.position.x > pi.x && h1.velocity.x > 0)
        || (h1.position.x < pi.x && h1.velocity.x < 0)
        || (h1.position.y > pi.y && h1.velocity.y > 0)
        || (h1.position.y < pi.y && h1.velocity.y < 0)
        || (h2.position.x > pi.x && h2.velocity.x > 0)
        || (h2.position.x < pi.x && h2.velocity.x < 0)
        || (h2.position.y > pi.y && h2.velocity.y > 0)
        || (h2.position.y < pi.y && h2.velocity.y < 0);

    inside_area && !in_the_past
}

fn count_collisions(configuration: &InputConfiguration, min_coord: i64, max_coord: i64) -> u32 {
    let mut count = 0;

    for (h1, h2) in configuration.hailstones.iter().tuple_combinations() {
        if paths_intersect_2d(h1, h2, min_coord, max_coord) {
            count += 1;
        }
    }

    count
}

enum PlanarProjection {
    XY,
    XZ,
}

/// Test the rock's velocity repesented by its negative `v_diff`. Try to find the intersection
/// point (pi) for each consecutive pair of hailstones. If each consecutive pair has the same
/// intersection point, then all hailstones intersect at this point, and this point is the rock's
/// position and the tested velocity is the rock's velocity.
///
/// Return the intersection point if it's unique, None otherwise.
fn test_velocity(
    cfg: &InputConfiguration,
    v_diff: Coord3,
    projection: PlanarProjection,
) -> Option<Coord2> {
    let mut candidate_pi = None;

    // It's enough to check all consecutive pairs of hailstones, rather than all combinations.
    for (h1, h2) in cfg.hailstones.iter().zip(cfg.hailstones.iter().skip(1)) {
        // Two points on the line created by the trajectory of the first hailstone, adjusted by the
        // velocity of the rock.
        let p1 = h1.position;
        let p2 = h1.position.add(&h1.velocity).add(&v_diff);

        // Two points on the line created by the trajectory of the second hailstone, adjusted by the
        // velocity of the rock.
        let p3 = h2.position;
        let p4 = h2.position.add(&h2.velocity).add(&v_diff);

        let (p1, p2, p3, p4) = [p1, p2, p3, p4]
            .map(|p| match projection {
                PlanarProjection::XY => p.project_to_xy(),
                PlanarProjection::XZ => p.project_to_xz(),
            })
            .into();

        let pi = cacl_intersection_point_1(&p1, &p2, &p3, &p4);

        match (candidate_pi, pi) {
            (None, Some(pi)) => candidate_pi = Some(pi),
            (Some(candidate_pi), Some(pi)) if pi != candidate_pi => return None,
            _ => {
                /* Do nothing. There are two options here:
                1. pi == None => The lines are parallel, so they will have the same intersection
                   point. However, we can't get the intersection point, so we just continue.
                2. pi != None && pi == candidate_pi => The intersection point remains unchanged.
                */
            },
        }
    }

    candidate_pi
}

/// For different values of vx and vy, create `v_diff` as the negative of the rock's velocity; then
/// test if this velocity has a unique intersection point for all hailstones. Return the
/// intersection point and velocity in x-y.
fn find_xy_position(cfg: &InputConfiguration, max_velocity: i64) -> Option<(Coord2, Coord2)> {
    for vx in 1..=max_velocity {
        for vy in 1..=max_velocity {
            for (vx, vy) in [(vx, vy), (-vx, vy), (vx, -vy), (-vx, -vy)] {
                let v_diff = Coord3 {
                    x: -vx,
                    y: -vy,
                    z: 0,
                };
                if let Some(pi) = test_velocity(cfg, v_diff, PlanarProjection::XY) {
                    return Some((pi, Coord2::from((vx, vy))));
                }
            }
        }
    }

    None
}

/// For fixed vx and different values of vz, create `v_diff` as the negative of the rock's
/// velocity; then test if this velocity has a unique intersection point for all hailstones. Return
/// the intersection point in x-z.
fn find_xz_position(cfg: &InputConfiguration, vx: i64, max_velocity: i64) -> Option<Coord2> {
    for vz in 1..=max_velocity {
        for (vx, vz) in [(vx, vz), (vx, -vz)] {
            let v_diff = Coord3 {
                x: -vx,
                y: 0,
                z: -vz,
            };
            if let Some(pi) = test_velocity(cfg, v_diff, PlanarProjection::XZ) {
                return Some(pi);
            }
        }
    }

    None
}

/// Compute how many of the hailstones' trajectories will intersect within a defined area. Ignore
/// the z axis and assume the hailstones are moving in 2D.
pub fn solve_part1(configuration: &InputConfiguration) -> u32 {
    let min_coord = 200_000_000_000_000_i64;
    let max_coord = 400_000_000_000_000_i64;
    count_collisions(configuration, min_coord, max_coord)
}

/// Compute a path of another stone (starting position and velocity) that will perfectly intersect
/// the paths of all of the hailstones. Return the sum of the coordinates of the starting position.
///
/// We brute force this solution by trying many different combinations of rock's velocity. The
/// algorithms works as follows: If we look at the coordinate system from the point of view of the
/// rock, then we can make the rock stationary and adjust the velocity of each hailstone by the
/// velocity of the rock. In this system, all the hailstones must pass through the rock's starting
/// position if we chose the rock's velocity correcty. In other words, with the adjusted velocity,
/// all the hailstones must intersect in a single point and this point is the starting position of
/// the rock. Therefore, we choose a velocity for the rock and check if all the hailstones
/// intersect in the same point. If so, we found the rock's starting position. Otherwise, we try
/// another velocity. To make the algotithm faster, we look for the x-y point first, then look for
/// the x-z point, once we've set the x and y coordinate.
pub fn solve_part2(configuration: &InputConfiguration) -> i64 {
    let max_velocity = 300;

    if let Some((p_xy, v_xy)) = find_xy_position(configuration, max_velocity) {
        if let Some(p_xz) = find_xz_position(configuration, v_xy.x, max_velocity) {
            if p_xy.x == p_xz.x {
                return p_xy.x + p_xy.y + p_xz.y;
            }
        }
    }

    panic!(
        "Brute force algorithm for part2 failed: Try increasing the max velocity to test new
        combinations of x/y/z velocity of the rock."
    );
}

#[cfg(test)]
mod tests {
    use indoc::indoc;

    use super::*;

    #[test]
    fn test1() {
        let input = indoc! {"
            19, 13, 30 @ -2, 1, -2
            18, 19, 22 @ -1, -1, -2
            20, 25, 34 @ -2, -2, -4
            12, 31, 28 @ -1, -2, -1
            20, 19, 15 @ 1, -5, -3
        "};

        let cfg = parser::parse_input(&input).unwrap();
        let result = count_collisions(&cfg, 7, 27);
        assert_eq!(result, 2);
        let result = solve_part2(&cfg);
        assert_eq!(result, 47);
    }
}
